<?php
/**
 * @file
 * Integrates with Tugboat.qa to allow creating on-the-fly preview sites.
 */

/**
 * Implements hook_config_info().
 */
function tugboat_config_info() {
  return array(
    'tugboat.settings' => array(
      'label' => t('Tugboat settings'),
      'group' => t('Configuration'),
    ),
  );
}

/**
 * Implements hook_menu().
 */
function tugboat_menu() {
  $config = config('tugboat.settings');
  $url = $config->get('page_url');
  $components = substr_count($url, '/');

  return array(
    'admin/config/services/tugboat' => array(
      'title' => 'Tugboat',
      'description' => 'Configure Tugboat.qa integration.',
      'page callback' => 'backdrop_get_form',
      'page arguments' => array('tugboat_admin_settings'),
      'access arguments' => array('administer tugboat settings'),
      'file' => 'tugboat.admin.inc',
    ),
    $url => array(
      'title' => $config->get('create_page_title'),
      'page callback' => 'tugboat_preview_create_page',
      'access arguments' => array('create tugboat preview sites'),
      'file' => 'tugboat.pages.inc',
    ),
    $url . '/%' => array(
      'title' => $config->get('ready_page_title'),
      'page callback' => 'tugboat_preview_ready_page',
      'page arguments' => array($components + 1),
      'access arguments' => array('create tugboat preview sites'),
      'file' => 'tugboat.pages.inc',
    ),
  );
}

/**
 * Implements hook_permission().
 */
function tugboat_permission() {
  return array(
    'administer tugboat settings' => array(
      'title' => t('Administer Tugboat settings'),
    ),
    'create tugboat preview sites' => array(
      'title' => t('Create Tugboat preview sites'),
    ),
  );
}

/**
 * Implements hook_theme().
 */
function tugboat_theme() {
  return array(
    'tugboat_preview_create_page' => array(
      'variables' => array('form' => NULL),
      'template' => 'templates/tugboat-preview-create-page',
    ),
    'tugboat_preview_ready_page' => array(
      'variables' => array('url' => NULL),
      'template' => 'templates/tugboat-preview-ready-page',
    ),
  );
}

/**
 * Implements hook_cron().
 *
 * Delete previews older than the specified age.
 */
function tugboat_cron() {
  $config = config('tugboat.settings');
  $age = $config->get('preview_site_age');

  // Run at an interval that matches the preview site age.
  if (REQUEST_TIME - state_get('tugboat_cron', 0) > $age) {
    state_set('tugboat_cron', REQUEST_TIME);
    $delete_timestamp = REQUEST_TIME - $age;
    $repo = $config->get('repository_id');

    $return = array();
    $error = '';
    $success = _tugboat_execute('ls previews repo=' . $repo, $return, $error);
    if (!$success) {
      watchdog('tugboat', 'Unable to find previews during cron run. Error from Tugboat: @error', array('@error' => '<code>' . check_plain($error) . '</code>'), WATCHDOG_ERROR);
    }

    $delete_count = 0;
    foreach ($return as $preview) {
      // Delete if not a base preview (anchor) and it's older than the specified age.
      if (!$preview['anchor'] && strtotime($preview['createdAt']) < $delete_timestamp) {
        $return = array();
        $error = '';
        $success = _tugboat_execute('delete ' . $preview['id'], $return, $error);
        if (!$success) {
          watchdog('tugboat', 'Unable to delete preview during cron run. Error from Tugboat: @error', array('@error' => '<code>' . check_plain($error) . '</code>'), WATCHDOG_ERROR);
        }
        else {
          $delete_count++;
        }
      }
    }

    if ($delete_count) {
      watchdog('tugboat', 'Deleted @count previews older than @date.', array('@count' => $delete_count, '@date' => format_date($delete_timestamp)));
    }
  }
}

/**
 * Execute a Tugboat CLI command.
 *
 * @param string $command
 *   The Tugboat command string with any options. The --api-token and --json
 *   options are passed automatically. Tugboat command portion should be
 *   specified in this string, such as "find <id>" or "stop <id>".
 * @param array $return
 *   Returned data as an array if the command was successful.
 * @param string $error
 *   A single error string if Tugboat returned an error or if it is not possible
 *   to reach Tugboat.
 * @param string $token
 *   Optional. The access token to use for the command. If not provided, the
 *   token in settings.php/config will be used.
 * @param string $path
 *   Optional. The path to the command line tool on the server. If not provided,
 *   the path in config will be used.
 *
 * @return bool
 */
function _tugboat_execute($command, array &$return, &$error, $token = NULL, $path = NULL) {
  // Get the Tugboat access token.
  // Check token from function parameter.
  if (empty($token)) {
    $token = settings_get('tugboat_access_token');
    // Check token from settings.php.
    if (empty($token)) {
      $token = config_get('tugboat.settings', 'access_token');
      // Check token from config.
      if (empty($token)) {
        $error = t('No access token was found.');
        return FALSE;
      }
    }
  }

  // Validate the path to the command line tool.
  if (empty($path)) {
    $path = config_get('tugboat.settings', 'command_line_tool');
  }
  if (!_tugboat_validate_path($path, $error)) {
    return FALSE;
  }

  // Ensure command string is safe from any dangerous characters.
  // Characters allowed: 0-9, a-z, =, +, -, ', and a blank space.
  if (!preg_match('#^[0-9a-z=+\-\' ]+$#', $command)) {
    $error = t('Invalid character(s) in Tugboat command: @string', array('@string' => '<code>' . $command . '</code>'));
    return FALSE;
  }

  // Run the command via the command line tool.
  $pipe_spec = array(
    0 => array('pipe', 'r'), // stdin pipe to send input.
    1 => array('pipe', 'w'), // stdout pipe to receive output.
    2 => array('pipe', 'w'), // errors pipe to receive output.
  );
  $pipes = array();
  $full_command = "$path --api-token=$token $command --json";
  $process = proc_open($full_command, $pipe_spec, $pipes);
  fclose($pipes[0]);
  $std_output = stream_get_contents($pipes[1]);
  $error_output = stream_get_contents($pipes[2]);
  fclose($pipes[1]);
  fclose($pipes[2]);
  $process_status = proc_get_status($process);
  $process_exit_code = $process_status['exitcode'];
  proc_close($process);

  // Process outputs.
  if ($error_output) {
    $error = trim($error_output);
  }
  if ($std_output) {
    $decoded_json = json_decode($std_output, TRUE);
    if ($decoded_json === NULL) {
      // Work-around for https://github.com/Lullabot/tugboat/issues/2999.
      // Use the last line of JSON output and ignore any progress information.
      if ($process_exit_code === 0) {
        $lines = explode("\n", $std_output);
        $last_line = end($lines);
        if ($decoded_json = json_decode($last_line, TRUE)) {
          $return = $decoded_json;
        }
      }
      $error = t('Unparseable JSON returned.');
    }
    else {
      $return = $decoded_json;
    }
  }

  return $process_exit_code === 0;
}

/**
 * Validate the path to the Tugboat command line tool.
 *
 * @param string $path
 *   The path to validate.
 * @param string $error
 *   The error if the path isn't valid.
 *
 * @return bool
 *   Whether or not the path is valid. If FALSE, $error will say why.
 */
function _tugboat_validate_path($path, &$error) {
  // Ensure file exists.
  if (!is_file($path)) {
    $error = t('No Tugboat command line tool found at the provided path.');
    return FALSE;
  }

  // Ensure file is executable.
  if (!is_executable($path)) {
    $error = t('The Tugboat command line tool was found, but it is not executable.');
    return FALSE;
  }

  return TRUE;
}
